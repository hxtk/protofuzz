package plugin

import (
	"unicode"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

var (
	fuzzPackage = protogen.GoImportPath("github.com/google/gofuzz")
)

func GenerateFile(gen *protogen.Plugin, file *protogen.File) {
	filename := file.GeneratedFilenamePrefix + ".pb.fuzz.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	genGeneratedHeader(gen, g)
	g.P("package ", file.GoPackageName)
	g.P()

	for _, v := range file.Messages {
		generateFuzzMethod(g, v, file.GoImportPath)
	}

	g.Import(fuzzPackage)
}

func genGeneratedHeader(gen *protogen.Plugin, g *protogen.GeneratedFile) {
	g.P("// Code generated by protoc-gen-go-fuzz. DO NOT EDIT.")
	g.P()
}

func varName(f string) string {
	for i, v := range f {
		return string(unicode.ToLower(v)) + f[i+1:]
	}
	return ""
}

var kindIdent = map[protoreflect.Kind]string{
	protoreflect.BoolKind:   "bool",
	protoreflect.Int32Kind:  "int32",
	protoreflect.Sint32Kind: "int32",
	protoreflect.Uint32Kind: "uint32",
	protoreflect.Int64Kind:  "int64",
	protoreflect.Sint64Kind: "int64",
	protoreflect.Uint64Kind: "uint64",
	protoreflect.FloatKind:  "float32",
	protoreflect.DoubleKind: "float64",
	protoreflect.StringKind: "string",
	protoreflect.BytesKind:  "[]byte",
}

func mapFieldType(g *protogen.GeneratedFile, m *protogen.Message, self protogen.GoImportPath) string {
	var keyIdent string
	switch m.Fields[0].Desc.Kind() {
	case protoreflect.MessageKind:
		keyIdent = msgFieldType(g, m.Fields[0], self)
	case protoreflect.EnumKind:
		fallthrough
	default:
		x, ok := kindIdent[m.Fields[0].Desc.Kind()]
		if !ok {
			panic("Unhandled map key type")
		}
		keyIdent = x
	}

	if m.Fields[0].Desc.IsList() {
		keyIdent = "[]" + keyIdent
	}

	var valueIdent string
	switch m.Fields[1].Desc.Kind() {
	case protoreflect.MessageKind:
		valueIdent = msgFieldType(g, m.Fields[1], self)
	case protoreflect.EnumKind:
		fallthrough
	default:
		x, ok := kindIdent[m.Fields[1].Desc.Kind()]
		if !ok {
			// Unhandled type, don't randomize.
			panic("Unhandled map value type")
		}
		valueIdent = x
	}

	if m.Fields[1].Desc.IsList() {
		valueIdent = "[]" + valueIdent
	}

	return "map[" + keyIdent + "]" + valueIdent
}

func msgFieldType(g *protogen.GeneratedFile, f *protogen.Field, self protogen.GoImportPath) string {
	ident := f.Message.GoIdent
	if f.Desc.IsMap() {
		return mapFieldType(g, f.Message, self)
	}

	if ident.GoImportPath != self {
		g.Import(ident.GoImportPath)
	}

	return `*` + g.QualifiedGoIdent(ident)
}

func generateFuzzMethod(g *protogen.GeneratedFile, m *protogen.Message, selfPath protogen.GoImportPath) {
	g.P(`// Fuzz implements github.com/google/gofuzz.Interface for `, m.GoIdent)
	g.P(`func (x *`, m.GoIdent, `) Fuzz(c_ `, fuzzPackage.Ident("Continue"), `) {`)
	for _, f := range m.Fields {
		if f.Desc.ContainingOneof() != nil {
			continue
		}

		var typeIdent string
		switch f.Desc.Kind() {
		case protoreflect.MessageKind:
			typeIdent = msgFieldType(g, f, selfPath)
		case protoreflect.EnumKind:
			fallthrough
		default:
			x, ok := kindIdent[f.Desc.Kind()]
			if !ok {
				// Unhandled type, don't randomize.
				continue
			}
			typeIdent = x
		}

		if f.Desc.IsList() {
			typeIdent = "[]" + typeIdent
		}

		g.P(`var `, varName(f.GoName), ` `, typeIdent)
		g.P(`c_.Fuzz(&`, varName(f.GoName), `)`)
		g.P(`x.`, f.GoName, ` = `, varName(f.GoName))
		g.P()
	}

	for _, oo := range m.Oneofs {
		g.P(`var `, varName(oo.GoName), ` is`, oo.GoIdent)
		g.P(`switch c_.Intn(`, len(oo.Fields), `) {`)
		for i, v := range oo.Fields {
			g.P(`case `, i, `:`)
			g.P(varName(oo.GoName), ` = new(`, v.GoIdent, `)`)
			g.P(`c_.Fuzz(&`, varName(oo.GoName), `.(*`, v.GoIdent, `).`, v.GoName, `)`)
		}
		g.P(`}`)
		g.P(`x.`, oo.GoName, ` = `, varName(oo.GoName))
	}
	g.P(`}`)
	g.P()
}
